{{>licenseInfo}}

import promise from 'es6-promise';
promise.polyfill();

import fetch from 'isomorphic-fetch';

/**
* @module {{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient
* @version {{projectVersion}}
*/

/**
* Manages low level client-server communications, parameter marshalling, etc. There should not be any need for an
* application to use this class directly - the *Api and model classes provide the public API for the service. The
* contents of this file should be regarded as internal but are documented for completeness.
* @alias module:{{#invokerPackage}}{{invokerPackage}}/{{/invokerPackage}}ApiClient
* @class
*/
export default class ApiClient {
    constructor(
        basePath = null,
        headers = null,
        timeout = null
    ) {
        /**
         * The base URL against which to resolve every API call's (relative) path.
         * @type {String}
         * @default {{&basePath}}
         */
        this.basePath = basePath === null ? '{{&basePath}}'.replace(/\/+$/, '') : basePath.replace(/\/+$/, '');

        /**
         * The authentication methods to be included for all API calls.
         * @type {String[]}
         */
        this.authentications = {
            {{#authMethods}}
                {{#isBasic}}
            '{{&name}}': {
                'type': 'basic'
            },
                {{/isBasic}}
                {{#isApiKey}}
            '{{&name}}': {
                'type': 'apiKey',
                    {{#isKeyInHeader}}
                'in': 'header',
                    {{/isKeyInHeader}}
                    {{^isKeyInHeader}}
                'in': 'query',
                    {{/isKeyInHeader}}
                'name': '{{keyParamName}}',
            },
                {{/isApiKey}}
                {{#isOAuth}}
            '{{&name}}': {
                    'type': 'oauth2',
            },
                {{/isOAuth}}
            {{/authMethods}}
        };

        /**
         * The default HTTP headers to be included for all API calls.
         * @type {Object}
         * @default {}
         */
        this.defaultHeaders = {};

        /**
         * The HTTP headers to be specific for this instance.
         * @type {Object}
         * @default {}
         */
        this.headers = headers === null ? {} : headers;

        /**
         * The default HTTP timeout for all API calls.
         * @type {Number}
         * @default null
         */
        this.timeout = timeout;
    }

    /**
     * Applies authentication headers to the request.
     * @param {Object} options The configuration object created for next fetch call.
     * @param {String[]} authNames An array of authentication method names.
     * @param {Object} credentials An object with good properties to use different types of authentication.
     */
    applyAuthToRequest(options, authNames, credentials) {
        authNames.forEach((authName) => {
            let auth = this.authentications[authName];
            switch (auth.type) {
                case 'oauth2':
                    if (credentials.hasOwnProperty('accessToken') === false || typeof credentials.accessToken === 'undefined') {
                        throw new Error('Oauth2 authentication claims an "accessToken" as credentials');
                    }

                    options.headers.append(auth.name, 'Bearer ' + credentials.accessToken)
                break;
                default:
                    throw new Error('Unknown authentication type: ' + auth.type);
            }
        });

        return options;
    }

    /**
     * Deserializes an HTTP response body into a value of the specified type.
     * @param {Object} response A SuperAgent response object.
     * @param {String|String[]|Object} returnType The type to return. Pass a string for simple types
     * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
     * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
     * all properties on datacode will be converted to this type.
     * @returns A value of the specified type.
     */
    deserialize(response, returnType) {
        if (response === null || returnType === null || response.status === 204) {
            return null;
        }

        let data = response.body;
        if (data === null || (typeof data === 'object' && typeof data.length === 'undefined' && !Object.keys(data).length)) {
            // SuperAgent does not always produce a body; use the unparsed response as a fallback
            data = response.text;
        }

        return exports.convertToType(data, returnType);
    }

    /**
     * Check code status of response
     */
    checkResponse(response) {
        if (response.status < 200 || response.status >= 300) {
            throw response;
        }
    }

    /**
     * Builds full URI by appending the given path to the base URL and replacing path parameter place-holders with parameter values.
     * NOTE: query parameters are not handled here.
     * @param {String} path The path to append to the base URL.
     * @param {Object} pathParams The parameter values to append.
     * @returns {String} The encoded path with parameter values substituted.
     */
    buildUri(path, pathParams) {
        if (!path.match(/^\//)) {
            path = '/' + path;
        }

        let uri = this.basePath + path;
        uri = uri.replace(/\{([\w-]+)\}/g, (fullMatch, key) => {
            let value = fullMatch;
            if (pathParams.hasOwnProperty(key)) {
                value = ApiClient.paramToString(pathParams[key]);
            }

            return encodeURIComponent(value);
        });

        return uri;
    }

    appendQueryParams(uri, queryParams = {}) {
        queryParam = this.normalizeParams(queryParams);

        let uriObject = url.parse(uri, true);
        uriObject.query = Object.assign({}, uriObject.query, queryParams);

        return url.format(uriObject);
    }

    /**
     * Order is important.
     */
    buildHeaders(headerParams, contentType, accept) {
        let headers = new Headers();

        headers.set('Content-Type', contentType);
        headers.set('Accept', accept);

        for (let property in this.defaultHeaders) {
            if (this.defaultHeaders.hasOwnProperty(property)) {
                headers.append(property, this.defaultHeaders[property]);
            }
        }

        for (let property in this.headers) {
            if (this.headers.hasOwnProperty(property)) {
                headers.append(property, this.headers[property]);
            }
        }

        for (let property in headerParams) {
            if (headerParams.hasOwnProperty(property)) {
                headers.append(property, headerParams[property]);
            }
        }
    }

    buildBody(contentType, bodyParams, formParams) {
        let body = null;
        switch(contentType) {
            case 'application/x-www-form-urlencoded':
                body = querystring.stringify(this.normalizeParams(formParams));
                break;
            default:
                body = bodyParams;
        }

        return body;
    }

    /**
     * Invokes the REST service using the supplied settings and parameters.
     * @param {String} path The base URL to invoke.
     * @param {String} httpMethod The HTTP method to use.
     * @param {Object} pathParams A map of path parameters and their values.
     * @param {Object} queryParams A map of query parameters and their values.
     * @param {Object} headerParams A map of header parameters and their values.
     * @param {Object} formParams A map of form parameters and their values.
     * @param {Object} bodyParam The value to pass as the request body.
     * @param {String[]} authNames An array of authentication type names.
     * @param {Object} credentials An object with good properties to use different types of authentication.
     * @param {String[]} contentTypes An array of request MIME types.
     * @param {String[]} accepts An array of acceptable response MIME types.
     * @param {(String|Array|Object|Function)} returnType The required type to return; can be a string for simple types or the constructor for a complex type.
     * @returns {Promise} A {@link https://www.promisejs.org/|Promise} object.
     */
    callApi(
        path,
        httpMethod,
        pathParams,
        queryParams,
        headerParams,
        formParams,
        bodyParam,
        authNames,
        credentials,
        contentTypes,
        accepts,
        returnType
    ) {
        let contentType = ApiClientUtils.jsonPreferredMime(contentTypes);
        let accept = ApiClientUtils.jsonPreferredMime(accepts);

        let uri = this.buildUri(path, pathParams);

        let url = this.appendQueryParams(uri, queryParams);

        let headers = this.buildHeaders(headerParams, contentType, accept);

        let body = this.buildBody(contentType, bodyParam, formParams);

        let options = {
            'body': body,
            'headers': headers,
            'method': httpMethod,
            'mode': 'cors',
        };

        // apply authentications
        options = this.applyAuthToRequest(options, authNames, credentials);

        if (this.timeout !== null) {
            options = Object.assign({}, { 'timeout': this.timeout }, options)
        }

        return fetch(url, options)
            .then((response) => {
                this.checkResponse(response);

                return response
                    .json()
                    .then((json) => {
                        try {
                            let data = this.deserialize(json, returnType);

                            return {
                                'data': data,
                                'response': json,
                            };
                        } catch (error) {
                            throw error;
                        }
                    });
            });
    }

    /**
     * Converts a value to the specified type.
     * @param {(String|Object)} data The data to convert, as a string or object.
     * @param {(String|String[]|Object|Function)} type The type to return. Pass a string for simple types
     * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
     * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
     * all properties on "data" will be converted to this type.
     * @returns An instance of the specified type or null or undefined if data is null or undefined.
     */
    static convertToType(data, type) {
        if (data === null || data === undefined)
            return data

        switch (type) {
            case 'Boolean':
                return Boolean(data);
            case 'Integer':
                return parseInt(data, 10);
            case 'Number':
                return parseFloat(data);
            case 'String':
                return String(data);
            case 'Date':
                return this.parseDate(String(data));
            case 'Blob':
                return data;
            default:
                if (type === Object) {
                    // generic object, return directly
                    return data;
                } else if (typeof type === 'function') {
                    // for model type like: User
                    return type.constructFromObject(data);
                } else if (Array.isArray(type)) {
                    // for array type like: ['String']
                    let itemType = type[0];

                    return data.map((item) => {
                        return exports.convertToType(item, itemType);
                    });
                } else if (typeof type === 'object') {
                    // for plain object type like: {'String': 'Integer'}
                    let keyType, valueType;
                    for (let k in type) {
                        if (type.hasOwnProperty(k)) {
                            keyType = k;
                            valueType = type[k];
                            break;
                        }
                    }

                    let result = {};
                    for (let k in data) {
                        if (data.hasOwnProperty(k)) {
                            let key = exports.convertToType(k, keyType);
                            let value = exports.convertToType(data[k], valueType);
                            result[key] = value;
                        }
                    }

                    return result;
                } else {
                    // for unknown type, return the data directly
                    return data;
                }
        }
    }

    /**
     * Constructs a new map or array model from REST data.
     * @param data {Object|Array} The REST data.
     * @param obj {Object|Array} The target object or array.
     */
    static constructFromObject(data, obj, itemType) {
        if (Array.isArray(data)) {
            for (let i = 0; i < data.length; i++) {
                if (data.hasOwnProperty(i))
                    obj[i] = exports.convertToType(data[i], itemType);
            }
        } else {
            for (let k in data) {
                if (data.hasOwnProperty(k))
                    obj[k] = exports.convertToType(data[k], itemType);
            }
        }
    }
}


class ApiClientUtils {
    /**
     * Checks whether the given parameter value represents file-like content.
     * @param param The parameter to check.
     * @returns {Boolean} "true" if "param" represents a file.
     */
    static isFileParam(param) {
        // fs.ReadStream in Node.js (but not in runtime like browserify)
        if (typeof window === 'undefined' && typeof require === 'function' && require('fs') && param instanceof require('fs').ReadStream) {
            return true;
        }

        // Buffer in Node.js
        if (typeof Buffer === 'function' && param instanceof Buffer) {
            return true;
        }

        // Blob in browser
        if (typeof Blob === 'function' && param instanceof Blob) {
            return true;
        }

        // File in browser (it seems File object is also instance of Blob, but keep this for safe)
        if (typeof File === 'function' && param instanceof File) {
            return true;
        }

        return false;
    }

    /**
     * Checks whether the given content type represents JSON.
     * JSON content type examples:
     * . "application/json"
     * . "application/json; charset=UTF8"
     * . "APPLICATION/JSON"
     * @param {String} contentType The MIME content type to check.
     * @returns {Boolean} "true" if "contentType" represents JSON, otherwise "false".
     */
    static isJsonMime(contentType) {
        return Boolean(contentType !== null && contentType.match(/^application\/json(;.*)?$/i));
    }

    /**
     * Chooses a content type from the given array, with JSON preferred; i.e. return JSON if included, otherwise return the first.
     * @param {String[]} contentTypes
     * @returns {String} The chosen content type, preferring JSON.
     */
    static jsonPreferredMime(contentTypes) {
        for (let i = 0; i < contentTypes.length; i++) {
            if (ApiClientUtils.isJsonMime(contentTypes[i])) {
                return contentTypes[i];
            }
        }

        return contentTypes[0];
    }

    /**
     * Normalizes parameter values:
     * remove nils
     * keep files and arrays
     * format to string with `paramToString` for other cases
     * @param {Object} params The parameters as object properties.
     * @returns {Object} normalized parameters.
     */
    static normalizeParams(params) {
        let newParams = {};
        for (let key in params) {
            if (params.hasOwnProperty(key) && typeof params[key] !== 'undefined' && params[key] !== null) {
                let value = params[key];

                if (ApiClientUtils.isFileParam(value) || Array.isArray(value)) {
                    newParams[key] = value;
                    continue;
                }

                newParams[key] = ApiClientUtils.paramToString(value);
            }
        }

        return newParams;
    }

    /**
     * Returns a string representation for an actual parameter.
     * @param param The actual parameter.
     * @returns {String} The string representation of param.
     */
    static paramToString(param) {
        if (typeof param === 'undefined' || param === null) {
            return '';
        }

        if (param instanceof Date) {
            return param.toJSON();
        }

        return param.toString();
    }

    /**
     * Parses an ISO-8601 string representation of a date value.
     * @param {String} str The date value as a string.
     * @returns {Date} The parsed date object.
     */
    static parseDate(str) {
        return new Date(str.replace(/T/i, ' '));
    }
}
